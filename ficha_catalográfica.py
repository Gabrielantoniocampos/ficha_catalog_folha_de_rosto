# -*- coding: utf-8 -*-
"""FICHA CATALOGRÁFICA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_8oSO493TA18rBKZXE6FPIEFE3luyih

Verificar questão de mais de 1 autoria
Condicional para para Vol.

VERSÃO II DO CÓDIGO
"""

!pip install pandas openpyxl python-docx

# prompt: excluir todos os arquivos gerados pelo processamento do meu codigo

import os
import shutil

# Define a pasta a ser excluída
pasta_saida = "fichas_final_com_tabelas"
caminho_zip = "fichas_tabelas_corrigidas.zip"

# Exclui a pasta e seu conteúdo
if os.path.exists(pasta_saida):
    shutil.rmtree(pasta_saida)
    print(f"Pasta '{pasta_saida}' e seu conteúdo foram excluídos com sucesso.")
else:
    print(f"Pasta '{pasta_saida}' não existe.")

# Exclui o arquivo zip
if os.path.exists(caminho_zip):
    os.remove(caminho_zip)
    print(f"Arquivo '{caminho_zip}' foi excluído com sucesso.")
else:
    print(f"Arquivo '{caminho_zip}' não existe.")

"""_____________________________"""

!pip install pandas openpyxl python-docx

import pandas as pd
from docx import Document
import os
import zipfile
import re
import shutil

# Caminhos
caminho_planilha = "/content/BASE_DE_FICHAS_PARA_AUTOMAÇÃO (2).xlsx"
caminho_template_ficha = "/content/Modelo_WBA0048_v3_Liderança_FC (1) (1).docx"
caminho_template_modelo = "/content/Modelo_WBA0048_v3_Liderança.docx"
pasta_saida = "fichas_final_com_tabelas"

# Cria pasta de saída principal
os.makedirs(pasta_saida, exist_ok=True)

# Carrega a planilha
df = pd.read_excel(caminho_planilha)

# Função para formatar o autor no estilo "Sobrenome, Nome"
def formatar_autor(nome):
    if pd.isna(nome):
        return ""
    partes = nome.strip().split()
    if len(partes) < 2:
        return nome
    sobrenome = partes[-1]
    restante = " ".join(partes[:-1])
    return f"{sobrenome}, {restante}"

# Limpar nomes para uso em pastas/arquivos
def limpar_nome_arquivo(texto):
    texto = str(texto)
    texto = texto.replace(":", "")  # Remove dois-pontos
    texto = re.sub(r'[\\/*?"<>|]', "", texto)
    return texto.strip()

# Aplica a formatação para a coluna AUTOR1
df['AUTOR_FORMATADO'] = df['AUTOR1'].apply(formatar_autor)

# Substituição segura em parágrafos
def substituir_em_paragrafo(par, dados):
    texto_original = par.text
    novo_texto = texto_original

    for chave, valor in dados.items():
        novo_texto = novo_texto.replace(chave, str(valor) if pd.notna(valor) else "")

    # Remover ": <SUBTITULO>" se o subtítulo estiver vazio
    if not dados.get('<SUBTITULO>'):
        novo_texto = re.sub(r':\s*<SUBTITULO>', '', novo_texto)

    # Remover ": v. <VOLUME>" se o volume estiver vazio
    if not dados.get('<VOLUME>'):
        novo_texto = re.sub(r':\s*v\.\s*<VOLUME>', '', novo_texto)

    if novo_texto != texto_original:
        for run in par.runs:
            run.text = ""
        par._element.clear_content()
        par.add_run(novo_texto)

# Substituir placeholders em todo o documento (inclusive tabelas)
def substituir_placeholders(doc, dados):
    for par in doc.paragraphs:
        substituir_em_paragrafo(par, dados)
    for tabela in doc.tables:
        for linha in tabela.rows:
            for celula in linha.cells:
                for par in celula.paragraphs:
                    substituir_em_paragrafo(par, dados)

# Gerar documentos
for i in range(len(df)):
    linha = df.iloc[i]

    # Volume tratado como inteiro
    volume_valor = linha['VOLUME']
    if pd.notna(volume_valor):
        try:
            volume_formatado = f": v. {int(float(volume_valor))}"
        except:
            volume_formatado = ""
    else:
        volume_formatado = ""

    # Título tratado sem ":" se subtítulo estiver vazio
    titulo_valor = str(linha['TITULO']).strip()
    subtitulo_valor = str(linha['SUBTITULO']).strip() if pd.notna(linha['SUBTITULO']) else ""
    if not subtitulo_valor and titulo_valor.endswith(":"):
        titulo_valor = titulo_valor[:-1].strip()

    substituicoes = {
        "<COORDENADOR>": linha['COORDENADOR'],
        "<REVISOR>": linha['REVISOR'],
        "<AUTOR>": linha['AUTOR_FORMATADO'],
        "<AUTOR1>": linha['AUTOR1'],
        "<AUTOR2>": linha['AUTOR2'],
        "<AUTOR3>": linha['AUTOR3'],
        "<CUTTER>": linha['CUTTER'],
        "<TITULO>": titulo_valor,
        "<SUBTITULO>": subtitulo_valor,
        "<PAGINA>": linha['PAGINA'],
        "<ISBN>": linha['ISBN'],
        "<PALAVRACHAVE1>": linha['PALAVRACHAVE1'],
        "<PALAVRACHAVE2>": linha['PALAVRACHAVE2'],
        "<PALAVRACHAVE3>": linha['PALAVRACHAVE3'],
        "<CDD>": linha['CDD'],
        "<VOLUME>": volume_formatado,
        "<NOME1>": linha['AUTOR_FORMATADO']  # Caso o modelo use <NOME1>
    }

    # Pasta por título
    autor_nome = limpar_nome_arquivo(linha['AUTOR_FORMATADO'])
    titulo_nome = limpar_nome_arquivo(titulo_valor)
    nome_pasta = f"{autor_nome} - {titulo_nome}"
    caminho_pasta = os.path.join(pasta_saida, nome_pasta)
    os.makedirs(caminho_pasta, exist_ok=True)

    # Gera ficha catalográfica
    doc_ficha = Document(caminho_template_ficha)
    substituir_placeholders(doc_ficha, substituicoes)
    nome_ficha = "Ficha Catalográfica.docx"
    doc_ficha.save(os.path.join(caminho_pasta, nome_ficha))

    # Gera documento modelo
    doc_modelo = Document(caminho_template_modelo)
    substituir_placeholders(doc_modelo, substituicoes)
    nome_modelo = "Modelo Preenchido.docx"
    doc_modelo.save(os.path.join(caminho_pasta, nome_modelo))

# Compactar tudo em ZIP
caminho_zip = "fichas_e_modelos.zip"
with zipfile.ZipFile(caminho_zip, 'w') as zipf:
    for pasta_raiz, _, arquivos in os.walk(pasta_saida):
        for arquivo in arquivos:
            caminho_completo = os.path.join(pasta_raiz, arquivo)
            caminho_relativo = os.path.relpath(caminho_completo, pasta_saida)
            zipf.write(caminho_completo, caminho_relativo)

print(f"✅ Processo finalizado! Arquivo zipado: {caminho_zip}")